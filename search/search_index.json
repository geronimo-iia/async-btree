{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Async Behaviour Tree for Python","text":"<p>Versions following Semantic Versioning</p> <p>See documentation.</p>"},{"location":"#overview","title":"Overview","text":""},{"location":"#whats-a-behavior-tree","title":"What's a behavior tree ?","text":"<p>Unlike a Finite State Machine, a Behaviour Tree is a tree of hierarchical nodes that controls the flow of decision and the execution of \"tasks\" or, as we will call them further, \"Actions\". -- behaviortree</p> <p>If your new (or not) about behavior tree, you could spend some time on this few links:</p> <ul> <li>Behavior trees for AI: How they work by Chris Simpson</li> <li>Introduction to BTs</li> </ul> <p>Few implementation libraries:</p> <ul> <li>task_behavior_engine A behavior tree based task engine written in Python</li> <li>pi_trees a Python/ROS library for implementing Behavior Trees</li> <li>pr_behavior_tree A simple python behavior tree library based on coroutines</li> <li>btsk Behavior Tree Starter Kit</li> <li>behave A behavior tree implementation in Python</li> </ul>"},{"location":"#why-another-library-so","title":"Why another library so ?","text":"<p>SIMPLICITY</p> <p>When you study behavior tree implementation, reactive node, dynamic change, runtime execution, etc ... At a moment you're build more or less something that mimic an evaluator 'eval/apply' or a compilator, with a complex hierachical set of class.</p> <p>All complexity came with internal state management, using tree of blackboard to avoid global variable, multithreading issue, maybe few callback etc ...</p> <p>This break the simplicity and beauty of your initial design.</p> <p>What I find usefull with behavior tree:</p> <ul> <li>clarity of expression</li> <li>node tree representation</li> <li>possibility to reuse behavior</li> <li>add external measure to dynamicaly change a behavior, a first step on observable pattern...</li> </ul> <p>As I've used OOP for years (very long time), I will try to avoid class tree and prefer using the power of functionnal programming to obtain what I want: add metadata on a sematic construction, deal with closure, use function in parameters or in return value...</p> <p>And a last reason, more personal, it that i would explore python expressivity.</p> <p>SO HOW ?</p> <p>In this module, I purpose you to use the concept of coroutines, and their mecanisms to manage the execution flow. By this way:</p> <ul> <li>we reuse simple language idiom to manage state, parameter, etc</li> <li>no design constraint on action implementation</li> <li>most of language build block could be reused</li> </ul> <p>You could build expression like this:</p> <pre><code>\nasync def a_func():\n    \"\"\"A great function\"\"\"\n    return \"a\"\n\nasync def b_decorator(child_value, other=\"\"):\n    \"\"\"A great decorator...\"\"\"\n    return f\"b{child_value}{other}\"\n\nassert run(decorate(a_func, b_decorator)) == \"ba\"\n\n</code></pre> <p>This expression apply <code>b_decorator</code> on function <code>a_func</code>.  Note that <code>decorate(a_func, b_decorator)</code> is not an async function, only action, or condition are async function.</p> <p>Few guidelines of this implementation:</p> <ul> <li>In order to mimic all NodeStatus (success, failure, running), I replace this by truthy/falsy meaning of evaluation value.   A special dedicated exception decorate standard exception in order to give them a Falsy meaning (<code>ControlFlowException</code>).   By default, exception are raised like happen usually until you catch them.</li> <li>Blackboard pattern, act as a manager of context variable for behavior tree.   With python 3, please... simply use contextvars !</li> <li>In order to be able to build a sematic tree, I've introduce a metadata tuple added on function implementation.</li> </ul> <p>The rest is just implementation details..</p> <p>A little note:</p> <p>You should not use this until you're ready to think about what you're doing :)</p>"},{"location":"#note-about-async-framework","title":"Note about 'async' framework","text":"<p>As we use async function as underlaying mechanism to manage the execution flow, the standard library asyncio is pretty fine. But, (always a but somewhere isn't it...), you should read this amazing blog post by Nathaniel J. Smith. And next study curio framework in deep.</p> <p>As curio say:</p> <p>Don't Use Curio if You're Allergic to Curio</p> <p>Personaly, after few time of testing and reading curio code, I'm pretty addict.</p> <p>If <code>curio</code> is not present, we default to <code>asyncio</code>.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install this library directly into an activated virtual environment with pip, Poetry or uv:</p> <ul> <li><code>python -m pip install async-btree</code> or <code>uv add async-btree</code> or <code>poetry add async-btree</code></li> <li>with with curio extention: <code>python -m pip install async-btree[curio]</code> or '<code>uv add async-btree[curio]</code></li> </ul>"},{"location":"#usage","title":"Usage","text":"<p>After installation, the package can imported:</p> <pre><code>$ python\n&gt;&gt;&gt; import async_btree\n&gt;&gt;&gt; async_btree.__version__\n</code></pre> <p>See API Reference documentation.</p> <p>With this framework, you didn't find any configuration file, no Xml, no json, no yaml.</p> <p>The main reason (oriented and personal point of view) is that you did not need to introduce an extra level of abtraction  to declare a composition of functions. I think it's true for most of main use case (except using an editor to wrote behaviour tree for example).</p> <p>So \"If you wrote your function with python, wrote composition in python\"...  (remember that you did not need XML to do SQL, just write good sql...)</p> <p>So, the goal is to:  - define your business function wich implements actions or conditions, with all test case that you wish/need  - compose them using those provided by this framework like <code>sequence</code>, <code>selector</code>, ...  - use them as it is or create a well define python module to reuse them</p> <p>Wanna style have an abtract tree of our behaviour tree ?</p> <p>Functions from async-btree build an abstract tree for you.  If you lookup in code, you should see an annotation \"node_metadata\" on internal implementation.  This decorator add basic information like function name, parameters, and children relation ship.</p> <p>This abstract tree can be retreived and stringified with <code>analyze</code> and <code>stringify_analyze</code>. Here the profile:</p> <pre><code>  def analyze(target: CallableFunction) -&gt; Node: # here we have our \"abtract tree code\"\n    ...\n</code></pre> <p>For example:</p> <pre><code>\n# your behaviour tree, or a sub tree:\nmy_func = alias(child=repeat_until(child=action(hello), condition=success_until_zero), name=\"btree_1\")\n\n# retrieve meta information and build a Node tree\nabstract_tree_tree_1 = analyze(my_func) \n\n# output the tree:\nprint(stringify_analyze(abstract_tree_tree_1))\n</code></pre> <p>This should print:</p> <pre><code> --&gt; btree_1:\n     --(child)--&gt; repeat_until:\n         --(condition)--&gt; success_until_zero:\n         --(child)--&gt; action:\n                      target: hello\n</code></pre> <p>Note about action and condition method:</p> <ul> <li>you could use sync or async function</li> <li>you could specify a return value with SUCCESS or FAILURE</li> <li>function with no return value will be evaluated as FAILURE until you decorate them with a <code>always_success</code>or <code>always_failure</code></li> </ul> <p>See this example/tutorial_1.py for more information.</p>"},{"location":"changelog/","title":"Change Log","text":""},{"location":"changelog/#142-2025-01-22","title":"1.4.2 (2025-01-22)","text":"<ul> <li>fix miss configuration with setuptool</li> </ul>"},{"location":"changelog/#141-2025-01-21","title":"1.4.1 (2025-01-21)","text":"<ul> <li>change poetry to uv as dependencies manager</li> <li>support python 3.12</li> </ul>"},{"location":"changelog/#140-2025-01-06","title":"1.4.0 (2025-01-06)","text":"<ul> <li>remove support of python 3.8</li> <li>update poetry usage with poet plugin</li> <li>update pyproject.toml declaration</li> <li>update dependencies management</li> <li>fix few type error</li> <li>extends test to 3.9, 3.11</li> <li>remove usage of black and isort for rust</li> <li>use pyright as sucessor or mypy</li> </ul>"},{"location":"changelog/#130-2023-10-07","title":"1.3.0 (2023-10-07)","text":"<ul> <li>add default parallel asyncio implementation if curio is not present.</li> <li>add run_once decorator</li> <li>bunp pytest dependency</li> <li>Deprecation notice on <code>async_btree.utils.run</code> </li> <li>Add BTreeRunner context manager to drive multiple independant btree execution.   This implementation works with curio and asyncio.   <code>asyncio</code> support only for python &gt;= 3.11.</li> <li>remove <code>__version__</code> package attribute. Single source of true is pyproject.toml and git.</li> </ul>"},{"location":"changelog/#120-2023-05-11","title":"1.2.0 (2023-05-11)","text":"<p>Features, from #24 :</p> <ul> <li>Removing inner exception handling, in order to code like usual, catch what we want and manage exception as needed</li> <li>add function failure_on_exception : avoid raising and manage it in btree with a false meaning</li> <li>add function ignore_exception : ignore specific exception</li> </ul> <p>Fix: - mypy cast issue on decorated function. - name attribute on operator - add test about metadata node name and properties - function name access compliant with mypi</p> <p>Technical Update:</p> <ul> <li>use local .venv directory for virtual env -&gt; better integration with visual studio</li> <li>update development dependencies</li> <li>use ruff as replacement of flake8, flakehell,...</li> <li>use mkdocs as replacement of sphinx</li> <li>simplify Makefile</li> <li>change 'master' branch for 'main'</li> </ul>"},{"location":"changelog/#111-2020-11-21","title":"1.1.1 (2020-11-21)","text":"<ul> <li>simplify <code>analyze</code> function</li> <li>fix parallele implementation</li> </ul>"},{"location":"changelog/#110-2020-11-20","title":"1.1.0 (2020-11-20)","text":"<ul> <li>remove falsy evaluation of exception</li> <li>add ignore_exception decorator</li> <li>use sync or async function in parameters operator</li> <li>decision control return Success per default rather than act as a failure if no failure tree dependency is set.</li> <li>add test on python 3.8</li> </ul>"},{"location":"changelog/#102-2020-11-15","title":"1.0.2 (2020-11-15)","text":"<ul> <li>update curio version &gt; 1</li> <li>add pytest-curio and rewrote test unit</li> </ul>"},{"location":"changelog/#101-2020-01-31","title":"1.0.1 (2020-01-31)","text":"<ul> <li>update from template-python</li> <li>use poetry 1.0.x</li> </ul>"},{"location":"changelog/#100-2019-09-01","title":"1.0.0 (2019-09-01)","text":"<ul> <li>rework documentation build process (see mkdocs folder)</li> <li>configure github page under master/docs</li> <li>configure documentation site on pypi</li> <li>add doc style on all function </li> <li>standardize parameter name</li> <li>fix dev documentation dependency</li> </ul>"},{"location":"changelog/#012-2019-07-05","title":"0.1.2 (2019-07-05)","text":"<ul> <li>Stable version flag</li> <li>Remove alpha note</li> </ul>"},{"location":"changelog/#011-2019-07-05","title":"0.1.1 (2019-07-05)","text":"<p>Removed version due to configuration error.</p>"},{"location":"changelog/#010-2019-07-05","title":"0.1.0 (2019-07-05)","text":"<ul> <li>Added Project Management: </li> <li>initial project structure based on jacebrowning/template-python</li> <li>initial project configuration</li> <li>follow Semantic Versioning</li> <li>configure travis-ci</li> <li>publish alpha version (not functional) on pypi</li> <li>configure coverage</li> <li>configure scrutinizer</li> <li>remove pylint.ini to a simple .pylintrc (add ide support)</li> <li>disable pylint bad-continuation (bug with pep8 formater)</li> <li>declare extra dependency</li> <li>configure black and isort</li> <li>refactorise makefile poetry run</li> <li>introduce flake8 as linter</li> <li>Documentation:</li> <li>replace mkdocs with pydoc-markdown</li> <li>Code:</li> <li>define 'definition' module to declare all common definiton of btree</li> <li>define 'utils' module to declare few async function like afilter, amap</li> <li>fix flake8 syntax error</li> <li>fix mypy typing error</li> <li>add basic test unit</li> <li>fix typing declaration</li> <li>complete code coverage</li> </ul>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or  advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic  address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a  professional setting</li> </ul>"},{"location":"code_of_conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at jguibert@gmail.com. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"contributing/","title":"Contributing","text":"<p>This project is based on Geronimo-iaa's Python Module Template. This is a cookiecutter template for a typical Python library following modern packaging conventions.  It utilizes popular libraries to fully automate all development and deployment tasks.</p>"},{"location":"contributing/#setup","title":"Setup","text":""},{"location":"contributing/#requirements","title":"Requirements","text":"<p>You will need:</p> <ul> <li>Python 3.9</li> <li>Pyenv</li> <li>uv </li> <li>Make</li> </ul>"},{"location":"contributing/#make-installation","title":"Make Installation","text":"<p>A powerfull tool: * macOS: <code>$ xcode-select --install</code> * Linux: https://www.gnu.org/software/make * Windows: https://mingw.org/download/installer</p>"},{"location":"contributing/#pyenv-installation","title":"Pyenv Installation","text":"<p>Pyenv will manage all our python version. Follow https://github.com/pyenv/pyenv#installation</p>"},{"location":"contributing/#python-installation","title":"Python Installation","text":"<p><code>$ pyenv install 3.9</code></p>"},{"location":"contributing/#uv-installation-httpsdocsastralshuvgetting-startedinstallation","title":"UV Installation: https://docs.astral.sh/uv/getting-started/installation/","text":"<p>UV will manage our dependencies and create our virtual environment for us.</p> <p>As we use poethepoet, you should define an alias like <code>alias poe=\"uv run poe\"</code>.</p>"},{"location":"contributing/#make-target-list","title":"Make Target list","text":"Name Comment make install Install project dependencies make lock Lock project dependencies"},{"location":"contributing/#poe-target-list","title":"Poe Target list","text":"Name Comment poe types Run the type checker poe lint Run linting tools on the code base poe style Validate black code style poe test Run unit tests poe check Run all checks on the code base poe build Builds module poe publish Publishes the package poe docs Builds  site documentation. poe docs-publish Build and publish site documentation. poe clean Delete all generated and temporary files poe requirements Generate requirements.txt <p>You could retrieve those commands with <code>poe</code>. It will output something like this :</p> <pre><code>Usage:\n  poe [global options] task [task arguments]\n\nGlobal options:\n  -h, --help            Show this help page and exit\n  --version             Print the version and exit\n  -v, --verbose         Increase command output (repeatable)\n  -q, --quiet           Decrease command output (repeatable)\n  -d, --dry-run         Print the task contents but don't actually run it\n  -C PATH, --directory PATH\n                        Specify where to find the pyproject.toml\n  -e EXECUTOR, --executor EXECUTOR\n                        Override the default task executor\n  --ansi                Force enable ANSI output\n  --no-ansi             Force disable ANSI output\n\nConfigured tasks:\n  types                 Run the type checker\n  lint                  Run linting tools on the code base\n  style                 Validate black code style\n  test                  Run unit tests\n  check                 Run all checks on the code base\n  build                 Build module\n  publish               Publish module\n  docs                  Build site documentation\n  docs-publish          Publish site documentation\n  clean                 Remove all generated and temporary files\n  requirements          Generate requirements.txt\n\n\n</code></pre>"},{"location":"license/","title":"License","text":"<p>The MIT License (MIT)</p> <p>Copyright \u00a9 2019, Jerome Guibert</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"reference/","title":"Reference","text":"<p>This part of the project documentation focuses on an information-oriented approach. Use it as a reference for the technical implementation of the <code>async_btree</code> project code.</p> <p>Declare async btree api.</p>"},{"location":"reference/#async_btree.AsyncInnerFunction","title":"<code>AsyncInnerFunction = Callable[[], Awaitable[Any]]</code>  <code>module-attribute</code>","text":"<p>Function signature of async function implementation.</p>"},{"location":"reference/#async_btree.CallableFunction","title":"<code>CallableFunction = Union[Callable[..., Awaitable[Any]], Callable]</code>  <code>module-attribute</code>","text":"<p>Something callable with or without async.</p>"},{"location":"reference/#async_btree.FAILURE","title":"<code>FAILURE = not SUCCESS</code>  <code>module-attribute</code>","text":"<p>Failure constant.</p>"},{"location":"reference/#async_btree.SUCCESS","title":"<code>SUCCESS = True</code>  <code>module-attribute</code>","text":"<p>Success constant.</p>"},{"location":"reference/#async_btree.BTreeRunner","title":"<code>BTreeRunner</code>","text":"<p>A context manager that call multiple async btree function in same context from sync framework.</p> <p><code>asyncio</code> provide a Runner (python &gt;= 3.11) to call several top-level async functions in the SAME context.</p> <p>The goal here is to hide underlaying asyncio framework.</p> <p>This function cannot be called when another asyncio event loop is running in the same thread.</p> <p>This function always creates a new event loop or Kernel and closes it at the end. It should be used as a main entry point for asyncio programs, and should ideally only be called once.</p> Source code in <code>async_btree/runner.py</code> <pre><code>class BTreeRunner:\n    \"\"\"A context manager that call multiple async btree function in same context from sync framework.\n\n    `asyncio` provide a Runner (python &gt;= 3.11) to call several top-level async functions in the SAME context.\n\n    The goal here is to hide underlaying asyncio framework.\n\n    This function cannot be called when another asyncio event loop is running in the same thread.\n\n    This function always creates a new event loop or Kernel and closes it at the end.\n    It should be used as a main entry point for asyncio programs, and should ideally only be called once.\n\n    \"\"\"\n\n    def __init__(self, disable_curio: bool = False) -&gt; None:\n        \"\"\"Create a runner to call ultiple async btree function in same context from existing sync framework.\n\n        Args:\n            disable_curio (bool, optional): Force usage of `asyncio` Defaults to False.\n\n        Raises:\n            RuntimeError: if python version is below 3.11 and disable_curio is set.\n        \"\"\"\n        self._has_curio = has_curio() and not disable_curio\n        self._context: Optional[Context] = None\n        # curio support\n        self._kernel: Optional[ContextManager] = None\n        # asyncio support\n        if not self._has_curio and sys.version_info.minor &lt; 11:\n            raise RuntimeError(\"asyncio support only for python 3.11\")\n        self._runner = None\n\n    def __enter__(self):\n        self._context = copy_context()\n\n        if self._has_curio:\n            from curio import Kernel\n\n            self._kernel = Kernel()\n        else:\n            from asyncio import Runner  # pyright: ignore[reportAttributeAccessIssue]\n\n            self._kernel = Runner()\n\n        self._kernel.__enter__()  # type: ignore\n\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        try:\n            self._kernel.__exit__(exc_type, exc_value, traceback)  # type: ignore\n        finally:\n            self._kernel = None\n            self._context = None\n\n    def run(self, target: Callable[..., Awaitable[R]], *args, **kwargs) -&gt; R:\n        \"\"\"Run an async btree coroutine in a same context.\n\n        Args:\n            target (Callable[..., Awaitable[R]]): coroutine\n\n        Raises:\n            RuntimeError: if context is not initialized\n\n        Returns:\n            R: result\n        \"\"\"\n        if not self._kernel:\n            raise RuntimeError(\"run method must be invoked inside a context.\")\n        coro = target(*args, **kwargs)\n        if self._has_curio:\n            return self._context.run(self._kernel.run, coro)  # type: ignore\n        return self._kernel.run(coro, context=self._context)  # type: ignore\n</code></pre>"},{"location":"reference/#async_btree.BTreeRunner.__init__","title":"<code>__init__(disable_curio=False)</code>","text":"<p>Create a runner to call ultiple async btree function in same context from existing sync framework.</p> <p>Parameters:</p> Name Type Description Default <code>disable_curio</code> <code>bool</code> <p>Force usage of <code>asyncio</code> Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if python version is below 3.11 and disable_curio is set.</p> Source code in <code>async_btree/runner.py</code> <pre><code>def __init__(self, disable_curio: bool = False) -&gt; None:\n    \"\"\"Create a runner to call ultiple async btree function in same context from existing sync framework.\n\n    Args:\n        disable_curio (bool, optional): Force usage of `asyncio` Defaults to False.\n\n    Raises:\n        RuntimeError: if python version is below 3.11 and disable_curio is set.\n    \"\"\"\n    self._has_curio = has_curio() and not disable_curio\n    self._context: Optional[Context] = None\n    # curio support\n    self._kernel: Optional[ContextManager] = None\n    # asyncio support\n    if not self._has_curio and sys.version_info.minor &lt; 11:\n        raise RuntimeError(\"asyncio support only for python 3.11\")\n    self._runner = None\n</code></pre>"},{"location":"reference/#async_btree.BTreeRunner.run","title":"<code>run(target, *args, **kwargs)</code>","text":"<p>Run an async btree coroutine in a same context.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Callable[..., Awaitable[R]]</code> <p>coroutine</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if context is not initialized</p> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>result</p> Source code in <code>async_btree/runner.py</code> <pre><code>def run(self, target: Callable[..., Awaitable[R]], *args, **kwargs) -&gt; R:\n    \"\"\"Run an async btree coroutine in a same context.\n\n    Args:\n        target (Callable[..., Awaitable[R]]): coroutine\n\n    Raises:\n        RuntimeError: if context is not initialized\n\n    Returns:\n        R: result\n    \"\"\"\n    if not self._kernel:\n        raise RuntimeError(\"run method must be invoked inside a context.\")\n    coro = target(*args, **kwargs)\n    if self._has_curio:\n        return self._context.run(self._kernel.run, coro)  # type: ignore\n    return self._kernel.run(coro, context=self._context)  # type: ignore\n</code></pre>"},{"location":"reference/#async_btree.ControlFlowException","title":"<code>ControlFlowException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>ControlFlowException exception is a decorator on a real exception.</p> <p>This will ensure that <code>assert ControlFlowException.__bool__ == False</code>. This permit to return exception as a 'FAILURE' status.</p> Source code in <code>async_btree/definition.py</code> <pre><code>class ControlFlowException(Exception):\n    \"\"\"ControlFlowException exception is a decorator on a real exception.\n\n    This will ensure that ```assert ControlFlowException.__bool__ == False```.\n    This permit to return exception as a 'FAILURE' status.\n    \"\"\"\n\n    def __init__(self, exception: Exception):\n        super().__init__()\n\n        self.exception = exception\n\n    def __bool__(self):\n        return False\n\n    def __repr__(self):\n        return self.exception.__repr__()\n\n    def __str__(self):\n        return self.exception.__str__()\n\n    @classmethod\n    def instanciate(cls, exception: Exception):\n        # this methods simplify usage of hierarchical call tree.\n        return exception if isinstance(exception, ControlFlowException) else ControlFlowException(exception=exception)\n</code></pre>"},{"location":"reference/#async_btree.Node","title":"<code>Node</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Node aggregate node definition implemented with NamedTuple.</p> <p>A Node is used to keep information on name, properties, and relations ship between a hierachical construct of functions. It's like an instance of NodeMetadata.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>named operation.</p> <code>properties</code> <code>list[tuple[str, Any]]</code> <p>a list of tuple (name, value) for definition.</p> <code>edges</code> <code>list[tuple[str, list[Any]]]</code> <p>a list of tuple (name, node list) for definition.</p> Notes <p>Edges attribut should be edges: <code>list[tuple[str, list['Node']]]</code> But it is impossible for now, see mypy issues 731</p> Source code in <code>async_btree/analyze.py</code> <pre><code>class Node(NamedTuple):\n    \"\"\"Node aggregate node definition implemented with NamedTuple.\n\n    A Node is used to keep information on name, properties, and relations ship\n    between a hierachical construct of functions.\n    It's like an instance of NodeMetadata.\n\n    Attributes:\n        name (str): named operation.\n        properties (list[tuple[str, Any]]): a list of tuple (name, value) for definition.\n        edges (list[tuple[str, list[Any]]]): a list of tuple (name, node list) for\n            definition.\n\n    Notes:\n        Edges attribut should be edges: ```list[tuple[str, list['Node']]]```\n        But it is impossible for now, see [mypy issues 731](https://github.com/python/mypy/issues/731)\n    \"\"\"\n\n    name: str\n    properties: list[tuple[str, Any]]\n    # edges: list[tuple[str, list['Node']]]\n    # https://github.com/python/mypy/issues/731\n    edges: list[tuple[str, list[Any]]]\n\n    def __str__(self):\n        return stringify_analyze(target=self)\n</code></pre>"},{"location":"reference/#async_btree.NodeMetadata","title":"<code>NodeMetadata</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>NodeMetadata is our node definition.</p> <p>A NodeMetadata is used to keep information on name, properties name, and relations ship name between a hierachical construct of functions.</p> <p>This permit us to print or analyze all information of a behaviour tree.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>named operation</p> <code>properties</code> <code>List[str]</code> <p>a list of property name (an int value, ...).</p> <code>edges</code> <code>List[str]</code> <p>a list of member name which act as edges (a child, ...).</p> Source code in <code>async_btree/definition.py</code> <pre><code>class NodeMetadata(NamedTuple):\n    \"\"\"NodeMetadata is our node definition.\n\n    A NodeMetadata is used to keep information on name, properties name,\n    and relations ship name between a hierachical construct of functions.\n\n    This permit us to print or analyze all information of a behaviour tree.\n\n    Attributes:\n        name (str): named operation\n        properties (List[str]): a list of property name (an int value, ...).\n        edges (List[str]): a list of member name which act as edges (a child, ...).\n\n    \"\"\"\n\n    name: str\n    properties: Optional[List[str]] = None\n    edges: Optional[List[str]] = None\n\n    @classmethod\n    def alias(cls, name: str, node: NodeMetadata, properties: Optional[List[str]] = None) -&gt; NodeMetadata:\n        return NodeMetadata(\n            name=name,\n            properties=properties if properties else node.properties,\n            edges=node.edges,\n        )\n</code></pre>"},{"location":"reference/#async_btree.action","title":"<code>action(target, **kwargs)</code>","text":"<p>Declare an action leaf.</p> <p>Action is an awaitable closure of specified function, (See alias function).</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>CallableFunction</code> <p>awaitable function</p> required <code>kwargs</code> <p>optional kwargs argument to pass on target function</p> <code>{}</code> <p>Returns:</p> Type Description <code>AsyncInnerFunction</code> <p>an awaitable function.</p> <p>Raises:</p> Type Description <code>ControlFlowException</code> <p>if error occurs</p> Source code in <code>async_btree/leaf.py</code> <pre><code>def action(target: CallableFunction, **kwargs) -&gt; AsyncInnerFunction:\n    \"\"\"Declare an action leaf.\n\n    Action is an awaitable closure of specified function,\n    (See alias function).\n\n    Args:\n        target (CallableFunction): awaitable function\n        kwargs: optional kwargs argument to pass on target function\n\n    Returns:\n        (AsyncInnerFunction): an awaitable function.\n\n    Raises:\n        ControlFlowException : if error occurs\n\n    \"\"\"\n\n    _target = to_async(target)\n\n    @node_metadata(properties=[\"_target\"])\n    async def _action():\n        try:\n            return await _target(**kwargs)\n        except Exception as e:\n            raise ControlFlowException.instanciate(e)\n\n    return _action\n</code></pre>"},{"location":"reference/#async_btree.afilter","title":"<code>afilter(corofunc, iterable)</code>  <code>async</code>","text":"<p>Filter an iterable or an async iterable with an async function.</p> <p>This simplify writing of filtering by a function on something iterable between 'async for ...' and 'for...' .</p> <p>Parameters:</p> Name Type Description Default <code>corofunc</code> <code>Callable[[Any], Awaitable[bool]]</code> <p>filter async function</p> required <code>iterable</code> <code>Union[AsyncIterable, Iterable]</code> <p>iterable or async iterable collection which will be applied.</p> required <p>Returns:</p> Type Description <code>AsyncGenerator[Any]</code> <p>an async iterator of item which satisfy corofunc(item) == True</p> Example <p><code>[i async for i in amap(inc, afilter(even, [0, 1, 2, 3, 4]))]</code></p> Source code in <code>async_btree/utils.py</code> <pre><code>async def afilter(\n    corofunc: Callable[[Any], Awaitable[bool]], iterable: Union[AsyncIterable, Iterable]\n) -&gt; AsyncGenerator[Any, None]:\n    \"\"\"Filter an iterable or an async iterable with an async function.\n\n    This simplify writing of filtering by a function on something iterable\n    between 'async for ...' and 'for...' .\n\n    Args:\n        corofunc (Callable[[Any], Awaitable[bool]]): filter async function\n        iterable (Union[AsyncIterable, Iterable]): iterable or async iterable collection\n            which will be applied.\n\n    Returns:\n        (AsyncGenerator[Any]): an async iterator of item which satisfy corofunc(item) == True\n\n    Example:\n        ```[i async for i in amap(inc, afilter(even, [0, 1, 2, 3, 4]))]```\n\n    \"\"\"\n    if isinstance(iterable, AsyncIterable):\n        async for item in iterable:\n            if await corofunc(item):\n                yield item\n    else:\n        for item in iterable:\n            if await corofunc(item):\n                yield item\n</code></pre>"},{"location":"reference/#async_btree.alias","title":"<code>alias(child, name)</code>","text":"<p>Define an alias on our child.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>CallableFunction</code> <p>child function to decorate</p> required <code>name</code> <code>str</code> <p>name of function tree</p> required <p>Returns:</p> Type Description <code>AsyncInnerFunction</code> <p>an awaitable function.</p> Source code in <code>async_btree/decorator.py</code> <pre><code>def alias(child: CallableFunction, name: str) -&gt; AsyncInnerFunction:\n    \"\"\"Define an alias on our child.\n\n    Args:\n        child (CallableFunction): child function to decorate\n        name (str): name of function tree\n\n    Returns:\n        (AsyncInnerFunction): an awaitable function.\n    \"\"\"\n\n    _child = to_async(child)\n\n    # we use a dedicted function to 'duplicate' the child reference\n    @node_metadata(name=name)\n    async def _alias():\n        return await _child()\n\n    return _alias\n</code></pre>"},{"location":"reference/#async_btree.always_failure","title":"<code>always_failure(child)</code>","text":"<p>Produce a function which always return FAILURE value.</p> Note <p>If you wanna git a failure even if an exception occurs, you have to decorate child with ignore_exception, like this:</p> <p><code>always_failure(child=ignore_exception(myfunction))</code></p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>CallableFunction</code> <p>child function to decorate</p> required <p>Returns:</p> Type Description <code>AsyncInnerFunction</code> <p>an awaitable function which return child result if is falsy else FAILURE.</p> <p>Raises:</p> Type Description <code>ControlFlowException</code> <p>if error occurs</p> Source code in <code>async_btree/decorator.py</code> <pre><code>def always_failure(child: CallableFunction) -&gt; AsyncInnerFunction:  # -&gt; Awaitable:\n    \"\"\"Produce a function which always return FAILURE value.\n\n    Note:\n        If you wanna git a failure even if an exception occurs, you have\n        to decorate child with ignore_exception, like this:\n\n        `always_failure(child=ignore_exception(myfunction))`\n\n    Args:\n        child (CallableFunction): child function to decorate\n\n    Returns:\n        (AsyncInnerFunction): an awaitable function which return child result if is falsy\n            else FAILURE.\n\n    Raises:\n        ControlFlowException : if error occurs\n\n    \"\"\"\n\n    _child = to_async(child)\n\n    @node_metadata()\n    async def _always_failure():\n        result: Any = FAILURE\n\n        try:\n            child_result = await _child()\n            if not bool(child_result):\n                result = child_result\n\n        except Exception as e:\n            raise ControlFlowException.instanciate(e)\n\n        return result\n\n    return _always_failure\n</code></pre>"},{"location":"reference/#async_btree.always_success","title":"<code>always_success(child)</code>","text":"<p>Create a node which always return SUCCESS value.</p> Note <p>If you wanna git a success even if an exception occurs, you have to decorate child with ignore_exception, like this:</p> <p><code>always_success(child=ignore_exception(myfunction))</code></p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>CallableFunction</code> <p>child function to decorate</p> required <p>Returns:</p> Type Description <code>AsyncInnerFunction</code> <p>an awaitable function which return child result if it is truthy else SUCCESS.</p> <p>Raises:</p> Type Description <code>ControlFlowException</code> <p>if error occurs</p> Source code in <code>async_btree/decorator.py</code> <pre><code>def always_success(child: CallableFunction) -&gt; AsyncInnerFunction:\n    \"\"\"Create a node which always return SUCCESS value.\n\n    Note:\n        If you wanna git a success even if an exception occurs, you have\n        to decorate child with ignore_exception, like this:\n\n        `always_success(child=ignore_exception(myfunction))`\n\n\n    Args:\n        child (CallableFunction): child function to decorate\n\n    Returns:\n        (AsyncInnerFunction): an awaitable function which return child result if it is truthy\n            else SUCCESS.\n\n    Raises:\n        ControlFlowException : if error occurs\n\n    \"\"\"\n\n    _child = to_async(child)\n\n    @node_metadata()\n    async def _always_success():\n        result: Any = SUCCESS\n\n        try:\n            child_result = await _child()\n            if bool(child_result):\n                result = child_result\n\n        except Exception as e:\n            raise ControlFlowException.instanciate(e)\n\n        return result\n\n    return _always_success\n</code></pre>"},{"location":"reference/#async_btree.amap","title":"<code>amap(corofunc, iterable)</code>  <code>async</code>","text":"<p>Map an async function onto an iterable or an async iterable.</p> <p>This simplify writing of mapping a function on something iterable between 'async for ...' and 'for...' .</p> <p>Parameters:</p> Name Type Description Default <code>corofunc</code> <code>Callable[[Any], Awaitable[T]]</code> <p>coroutine function</p> required <code>iterable</code> <code>Union[AsyncIterable, Iterable]</code> <p>iterable or async iterable collection which will be applied.</p> required <p>Returns:</p> Type Description <code>AsyncGenerator[T, None]</code> <p>AsyncGenerator[T]: an async iterator of corofunc(item)</p> Example <p><code>[i async for i in amap(inc, afilter(even, [0, 1, 2, 3, 4]))]</code></p> Source code in <code>async_btree/utils.py</code> <pre><code>async def amap(\n    corofunc: Callable[[Any], Awaitable[T]], iterable: Union[AsyncIterable, Iterable]\n) -&gt; AsyncGenerator[T, None]:\n    \"\"\"Map an async function onto an iterable or an async iterable.\n\n    This simplify writing of mapping a function on something iterable\n    between 'async for ...' and 'for...' .\n\n    Args:\n        corofunc (Callable[[Any], Awaitable[T]]): coroutine function\n        iterable (Union[AsyncIterable, Iterable]): iterable or async iterable collection\n            which will be applied.\n\n    Returns:\n        AsyncGenerator[T]: an async iterator of corofunc(item)\n\n    Example:\n        ```[i async for i in amap(inc, afilter(even, [0, 1, 2, 3, 4]))]```\n\n    \"\"\"\n    if isinstance(iterable, AsyncIterable):\n        async for item in iterable:\n            yield await corofunc(item)\n    else:\n        for item in iterable:\n            yield await corofunc(item)\n</code></pre>"},{"location":"reference/#async_btree.condition","title":"<code>condition(target, **kwargs)</code>","text":"<p>Declare a condition leaf.</p> <p>Condition is an awaitable closure of specified function.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>CallableFunction</code> <p>awaitable function which be evaluated as True/False.</p> required <code>kwargs</code> <p>optional kwargs argument to pass on target function</p> <code>{}</code> <p>Returns:</p> Type Description <code>AsyncInnerFunction</code> <p>an awaitable function.</p> Source code in <code>async_btree/leaf.py</code> <pre><code>def condition(target: CallableFunction, **kwargs) -&gt; AsyncInnerFunction:\n    \"\"\"Declare a condition leaf.\n\n    Condition is an awaitable closure of specified function.\n\n    Args:\n        target (CallableFunction):  awaitable function which be evaluated as True/False.\n        kwargs: optional kwargs argument to pass on target function\n\n    Returns:\n        (AsyncInnerFunction): an awaitable function.\n    \"\"\"\n    return alias_node_metadata(\n        name=\"condition\",\n        target=is_success(action(target=target, **kwargs)),\n        properties=[\"target\"],\n    )\n</code></pre>"},{"location":"reference/#async_btree.decision","title":"<code>decision(condition, success_tree, failure_tree=None)</code>","text":"<p>Create a decision node.</p> <p>If condition is meet, return evaluation of success_tree. Otherwise, it return SUCCESS or evaluation of failure_tree if setted.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>CallableFunction</code> <p>awaitable condition</p> required <code>success_tree</code> <code>CallableFunction</code> <p>awaitable success tree which be evaluated if cond is Truthy</p> required <code>failure_tree</code> <code>CallableFunction</code> <p>awaitable failure tree which be evaluated if cond is Falsy (None per default)</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncInnerFunction</code> <p>an awaitable function.</p> Source code in <code>async_btree/control.py</code> <pre><code>def decision(\n    condition: CallableFunction,\n    success_tree: CallableFunction,\n    failure_tree: Optional[CallableFunction] = None,\n) -&gt; AsyncInnerFunction:\n    \"\"\"Create a decision node.\n\n    If condition is meet, return evaluation of success_tree.\n    Otherwise, it return SUCCESS or evaluation of failure_tree if setted.\n\n    Args:\n        condition (CallableFunction): awaitable condition\n        success_tree (CallableFunction): awaitable success tree which be\n            evaluated if cond is Truthy\n        failure_tree (CallableFunction): awaitable failure tree which be\n            evaluated if cond is Falsy (None per default)\n\n    Returns:\n        (AsyncInnerFunction): an awaitable function.\n    \"\"\"\n\n    _condition = to_async(condition)\n    _success_tree = to_async(success_tree)\n    _failure_tree = to_async(failure_tree) if failure_tree else None\n\n    @node_metadata(edges=[\"_condition\", \"_success_tree\", \"_failure_tree\"])\n    async def _decision():\n        if bool(await _condition()):\n            return await _success_tree()\n        if _failure_tree:\n            return await _failure_tree()\n        return SUCCESS\n\n    return _decision\n</code></pre>"},{"location":"reference/#async_btree.decorate","title":"<code>decorate(child, decorator, **kwargs)</code>","text":"<p>Create a decorator.</p> <p>Post process a child with specified decorator function. First argument of decorator function must be a child.</p> <p>This method implement a simple lazy evaluation.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>CallableFunction</code> <p>child function to decorate</p> required <code>decorator</code> <code>CallableFunction</code> <p>awaitable target decorator with profile 'decorator(child_result, **kwargs)'</p> required <code>kwargs</code> <p>optional keyed argument to pass to decorator function</p> <code>{}</code> <p>Returns:</p> Type Description <code>AsyncInnerFunction</code> <p>an awaitable function which     return decorator evaluation against child.</p> Source code in <code>async_btree/decorator.py</code> <pre><code>def decorate(child: CallableFunction, decorator: CallableFunction, **kwargs) -&gt; AsyncInnerFunction:\n    \"\"\"Create a decorator.\n\n    Post process a child with specified decorator function.\n    First argument of decorator function must be a child.\n\n    This method implement a simple lazy evaluation.\n\n    Args:\n        child (CallableFunction): child function to decorate\n        decorator (CallableFunction): awaitable target decorator with profile 'decorator(child_result, **kwargs)'\n        kwargs: optional keyed argument to pass to decorator function\n\n    Returns:\n      (AsyncInnerFunction): an awaitable function which\n            return decorator evaluation against child.\n    \"\"\"\n\n    _child = to_async(child)\n    _decorator = to_async(decorator)\n\n    @node_metadata(properties=[\"_decorator\"])\n    async def _decorate():\n        return await _decorator(await _child(), **kwargs)\n\n    return _decorate\n</code></pre>"},{"location":"reference/#async_btree.fallback","title":"<code>fallback(children)</code>","text":"<p>Execute tasks in sequence and succeed if one succeed or failed if all failed.</p> <p>Often named 'selector', children can be seen as an ordered list     starting from higthest priority to lowest priority.</p> <p>Parameters:</p> Name Type Description Default <code>children</code> <code>list[CallableFunction]</code> <p>list of Awaitable</p> required <p>Returns:</p> Type Description <code>AsyncInnerFunction</code> <p>an awaitable function.</p> Source code in <code>async_btree/control.py</code> <pre><code>def fallback(children: list[CallableFunction]) -&gt; AsyncInnerFunction:\n    \"\"\"Execute tasks in sequence and succeed if one succeed or failed if all failed.\n\n    Often named 'selector', children can be seen as an ordered list\n        starting from higthest priority to lowest priority.\n\n    Args:\n        children (list[CallableFunction]): list of Awaitable\n\n    Returns:\n        (AsyncInnerFunction): an awaitable function.\n    \"\"\"\n    return alias_node_metadata(\n        name=\"fallback\",\n        target=sequence(children, succes_threshold=min(1, len(children))),\n    )\n</code></pre>"},{"location":"reference/#async_btree.ignore_exception","title":"<code>ignore_exception(child)</code>","text":"<p>Create a node which ignore runtime exception.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>CallableFunction</code> <p>child function to decorate</p> required <p>Returns:</p> Type Description <code>AsyncInnerFunction</code> <p>an awaitable function which return child result</p> <code>AsyncInnerFunction</code> <p>or any exception with a falsy meaning in a ControlFlowException.</p> Source code in <code>async_btree/decorator.py</code> <pre><code>def ignore_exception(child: CallableFunction) -&gt; AsyncInnerFunction:\n    \"\"\"Create a node which ignore runtime exception.\n\n    Args:\n        child (CallableFunction): child function to decorate\n\n    Returns:\n        (AsyncInnerFunction): an awaitable function which return child result\n        or any exception with a falsy meaning in a ControlFlowException.\n\n    \"\"\"\n\n    _child = to_async(child)\n\n    @node_metadata()\n    async def _ignore_exception():\n        try:\n            return await _child()\n\n        except Exception as e:\n            return ControlFlowException.instanciate(e)\n\n    return _ignore_exception\n</code></pre>"},{"location":"reference/#async_btree.inverter","title":"<code>inverter(child)</code>","text":"<p>Invert node status.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>CallableFunction</code> <p>child function to decorate</p> required <p>Returns:</p> Type Description <code>AsyncInnerFunction</code> <p>an awaitable function which return SUCCESS if child return FAILURE else SUCCESS</p> Source code in <code>async_btree/decorator.py</code> <pre><code>def inverter(child: CallableFunction) -&gt; AsyncInnerFunction:\n    \"\"\"Invert node status.\n\n    Args:\n        child (CallableFunction): child function to decorate\n\n    Returns:\n        (AsyncInnerFunction): an awaitable function which return SUCCESS if child\n            return FAILURE else SUCCESS\n    \"\"\"\n\n    _child = to_async(child)\n\n    @node_metadata()\n    async def _inverter():\n        return not bool(await _child())\n\n    return _inverter\n</code></pre>"},{"location":"reference/#async_btree.is_failure","title":"<code>is_failure(child)</code>","text":"<p>Create a conditional node which test if child fail.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>CallableFunction</code> <p>child function to decorate</p> required <p>Returns:</p> Type Description <code>AsyncInnerFunction</code> <p>an awaitable function which return SUCCESS if child return FAILURE else FAILURE.</p> Source code in <code>async_btree/decorator.py</code> <pre><code>def is_failure(child: CallableFunction) -&gt; AsyncInnerFunction:\n    \"\"\"Create a conditional node which test if child fail.\n\n    Args:\n        child (CallableFunction): child function to decorate\n\n    Returns:\n        (AsyncInnerFunction): an awaitable function which return SUCCESS if child\n            return FAILURE else FAILURE.\n    \"\"\"\n\n    _child = to_async(child)\n\n    @node_metadata()\n    async def _is_failure():\n        return SUCCESS if not bool(await _child()) else FAILURE\n\n    return _is_failure\n</code></pre>"},{"location":"reference/#async_btree.is_success","title":"<code>is_success(child)</code>","text":"<p>Create a conditional node which test if child success.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>CallableFunction</code> <p>child function to decorate</p> required <p>Returns:</p> Type Description <code>AsyncInnerFunction</code> <p>an awaitable function which return SUCCESS if child return SUCCESS else FAILURE.</p> Source code in <code>async_btree/decorator.py</code> <pre><code>def is_success(child: CallableFunction) -&gt; AsyncInnerFunction:\n    \"\"\"Create a conditional node which test if child success.\n\n    Args:\n        child (CallableFunction): child function to decorate\n\n    Returns:\n        (AsyncInnerFunction): an awaitable function which return SUCCESS if child\n            return SUCCESS else FAILURE.\n    \"\"\"\n\n    _child = to_async(child)\n\n    @node_metadata()\n    async def _is_success():\n        return SUCCESS if bool(await _child()) else FAILURE\n\n    return _is_success\n</code></pre>"},{"location":"reference/#async_btree.node_metadata","title":"<code>node_metadata(name=None, properties=None, edges=None)</code>","text":"<p>'node_metadata' is a function decorator which add meta information about node.</p> <p>We add a property on decorated function named '__node_metadata'.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>override name of decorated function, default is function name left striped with '_'</p> <code>None</code> <code>properties</code> <code>Optional[List[str]]</code> <p>a list of property name ([] as default)</p> <code>None</code> <code>edges</code> <code>Optional[List[str]]</code> <p>a list of edges name ([\"child\", \"children\"] as default)</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], FunctionWithMetadata[P, R]]</code> <p>the decorator function</p> Source code in <code>async_btree/definition.py</code> <pre><code>def node_metadata(\n    name: Optional[str] = None,\n    properties: Optional[List[str]] = None,\n    edges: Optional[List[str]] = None,\n) -&gt; Callable[[Callable[P, R]], FunctionWithMetadata[P, R]]:\n    \"\"\"'node_metadata' is a function decorator which add meta information about node.\n\n    We add a property on decorated function named '__node_metadata'.\n\n    Args:\n        name (Optional[str]): override name of decorated function,\n            default is function name left striped with '_'\n        properties (Optional[List[str]]): a list of property name ([] as default)\n        edges (Optional[List[str]]): a list of edges name\n            ([\"child\", \"children\"] as default)\n\n    Returns:\n        the decorator function\n\n    \"\"\"\n\n    def decorate_function(function: Callable[P, R]) -&gt; FunctionWithMetadata[P, R]:\n        dfunc = _attr_decorator(function)\n\n        dfunc.__node_metadata = getattr(\n            dfunc,\n            \"__node_metadata\",\n            NodeMetadata(\n                name=name if name else get_function_name(target=dfunc),\n                properties=properties,\n                edges=edges,\n            ),\n        )\n        return cast(FunctionWithMetadata[P, R], dfunc)\n\n    return decorate_function\n</code></pre>"},{"location":"reference/#async_btree.repeat_until","title":"<code>repeat_until(condition, child)</code>","text":"<p>Repeat child evaluation until condition is truthy.</p> <p>Return last child evaluation or FAILURE if no evaluation occurs.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>CallableFunction</code> <p>awaitable condition</p> required <code>child</code> <code>CallableFunction</code> <p>awaitable child</p> required <p>Returns:</p> Type Description <code>AsyncInnerFunction</code> <p>an awaitable function.</p> Source code in <code>async_btree/control.py</code> <pre><code>def repeat_until(condition: CallableFunction, child: CallableFunction) -&gt; AsyncInnerFunction:\n    \"\"\"Repeat child evaluation until condition is truthy.\n\n    Return last child evaluation or FAILURE if no evaluation occurs.\n\n    Args:\n        condition (CallableFunction): awaitable condition\n        child (CallableFunction): awaitable child\n\n    Returns:\n        (AsyncInnerFunction): an awaitable function.\n    \"\"\"\n\n    _child = to_async(child)\n    _condition = to_async(condition)\n\n    @node_metadata(edges=[\"_condition\", \"_child\"])\n    async def _repeat_until():\n        result: Any = FAILURE\n        while bool(await _condition()):\n            result = await _child()\n\n        return result\n\n    return _repeat_until\n</code></pre>"},{"location":"reference/#async_btree.retry","title":"<code>retry(child, max_retry=3)</code>","text":"<p>Retry child evaluation at most max_retry time on failure until child succeed.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>CallableFunction</code> <p>child function to decorate</p> required <code>max_retry</code> <code>int</code> <p>max retry count (default 3), -1 mean infinite retry</p> <code>3</code> <p>Returns:</p> Type Description <code>AsyncInnerFunction</code> <p>an awaitable function which retry child evaluation at most max_retry time on failure until child succeed. If max_retry is reached, returns FAILURE or last exception.</p> Source code in <code>async_btree/decorator.py</code> <pre><code>def retry(child: CallableFunction, max_retry: int = 3) -&gt; AsyncInnerFunction:\n    \"\"\"Retry child evaluation at most max_retry time on failure until child succeed.\n\n    Args:\n        child (CallableFunction): child function to decorate\n        max_retry (int): max retry count (default 3), -1 mean infinite retry\n\n    Returns:\n        (AsyncInnerFunction): an awaitable function which retry child evaluation\n            at most max_retry time on failure until child succeed.\n            If max_retry is reached, returns FAILURE or last exception.\n    \"\"\"\n    if not (max_retry &gt; 0 or max_retry == -1):\n        raise AssertionError(\"max_retry\")\n\n    _child = to_async(child)\n\n    @node_metadata(properties=[\"max_retry\"])\n    async def _retry():\n        retry_count = max_retry\n        result: Any = FAILURE\n\n        while not bool(result) and retry_count != 0:\n            result = await _child()\n            print(f\"result : {result}\")\n            retry_count -= 1\n\n        return result\n\n    return _retry\n</code></pre>"},{"location":"reference/#async_btree.retry_until_failed","title":"<code>retry_until_failed(child)</code>","text":"<p>Retry child until failed.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>CallableFunction</code> <p>child function to decorate</p> required <p>Returns:</p> Type Description <code>AsyncInnerFunction</code> <p>an awaitable function which try to evaluate child until it failed.</p> Source code in <code>async_btree/decorator.py</code> <pre><code>def retry_until_failed(child: CallableFunction) -&gt; AsyncInnerFunction:\n    \"\"\"Retry child until failed.\n\n    Args:\n        child (CallableFunction): child function to decorate\n\n    Returns:\n        (AsyncInnerFunction): an awaitable function which try to evaluate child\n            until it failed.\n    \"\"\"\n\n    return alias_node_metadata(name=\"retry_until_failed\", target=retry(child=inverter(child), max_retry=-1))\n</code></pre>"},{"location":"reference/#async_btree.retry_until_success","title":"<code>retry_until_success(child)</code>","text":"<p>Retry child until success.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>CallableFunction</code> <p>child function to decorate</p> required <p>Returns:</p> Type Description <code>AsyncInnerFunction</code> <p>an awaitable function which try to evaluate child until it succeed.</p> Source code in <code>async_btree/decorator.py</code> <pre><code>def retry_until_success(child: CallableFunction) -&gt; AsyncInnerFunction:\n    \"\"\"Retry child until success.\n\n    Args:\n        child (CallableFunction): child function to decorate\n\n    Returns:\n        (AsyncInnerFunction): an awaitable function which try to evaluate child\n            until it succeed.\n    \"\"\"\n    return alias_node_metadata(name=\"retry_until_success\", target=retry(child=child, max_retry=-1))\n</code></pre>"},{"location":"reference/#async_btree.run","title":"<code>run(kernel, target, *args)</code>","text":"<p>Curio run with independent contextvars.</p> <p>This mimic asyncio framework behaviour. We use a contextvars per run rather than use one per task with <code>from curio.task.ContextTask</code></p> <pre><code>copy_context().run(kernel.run, target, *args)\n</code></pre> Source code in <code>async_btree/utils.py</code> <pre><code>def run(kernel, target, *args):\n    \"\"\"Curio run with independent contextvars.\n\n    This mimic asyncio framework behaviour.\n    We use a contextvars per run rather than use one per task with `from curio.task.ContextTask`\n\n    ```\n    copy_context().run(kernel.run, target, *args)\n    ```\n\n    \"\"\"\n    warn(\"This method is deprecated.\", DeprecationWarning, stacklevel=2)\n    return copy_context().run(kernel.run, target, *args)\n</code></pre>"},{"location":"reference/#async_btree.selector","title":"<code>selector(children)</code>","text":"<p>Synonym of fallback.</p> Source code in <code>async_btree/control.py</code> <pre><code>def selector(children: list[CallableFunction]) -&gt; AsyncInnerFunction:\n    \"\"\"Synonym of fallback.\"\"\"\n    return alias_node_metadata(\n        name=\"selector\",\n        target=sequence(children, succes_threshold=min(1, len(children))),\n    )\n</code></pre>"},{"location":"reference/#async_btree.sequence","title":"<code>sequence(children, succes_threshold=None)</code>","text":"<p>Return a function which execute children in sequence.</p> <p>succes_threshold parameter generalize traditional sequence/fallback and must be in [0, len(children)]. Default value is (-1) means len(children)</p> <p>if #success = succes_threshold, return a success</p> <p>if #failure = len(children) - succes_threshold, return a failure</p> <p>What we can return as value and keep sematic Failure/Success:  - an array of previous result when success  - last failure when fail</p> <p>Parameters:</p> Name Type Description Default <code>children</code> <code>list[CallableFunction]</code> <p>list of Awaitable</p> required <code>succes_threshold</code> <code>int</code> <p>succes threshold value</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncInnerFunction</code> <p>an awaitable function.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>if succes_threshold is invalid</p> Source code in <code>async_btree/control.py</code> <pre><code>def sequence(children: list[CallableFunction], succes_threshold: Optional[int] = None) -&gt; AsyncInnerFunction:\n    \"\"\"Return a function which execute children in sequence.\n\n    succes_threshold parameter generalize traditional sequence/fallback and\n    must be in [0, len(children)]. Default value is (-1) means len(children)\n\n    if #success = succes_threshold, return a success\n\n    if #failure = len(children) - succes_threshold, return a failure\n\n    What we can return as value and keep sematic Failure/Success:\n     - an array of previous result when success\n     - last failure when fail\n\n    Args:\n        children (list[CallableFunction]): list of Awaitable\n        succes_threshold (int): succes threshold value\n\n    Returns:\n        (AsyncInnerFunction): an awaitable function.\n\n    Raises:\n        (AssertionError): if succes_threshold is invalid\n    \"\"\"\n    _succes_threshold = succes_threshold or len(children)\n    if not (0 &lt;= _succes_threshold &lt;= len(children)):\n        raise AssertionError(\"succes_threshold\")\n\n    failure_threshold = len(children) - _succes_threshold + 1\n\n    _children = [to_async(child) for child in children]\n\n    @node_metadata(properties=[\"_succes_threshold\"])\n    async def _sequence():\n        success = 0\n        failure = 0\n        results = []\n\n        for child in _children:\n            last_result = await child()\n            results.append(last_result)\n\n            if bool(last_result):\n                success += 1\n                if success == _succes_threshold:\n                    # last evaluation is a success\n                    return results\n            else:\n                failure += 1\n                if failure == failure_threshold:\n                    # last evaluation is a failure\n                    return last_result\n        # should be never reached\n        return FAILURE\n\n    return _sequence\n</code></pre>"},{"location":"reference/#async_btree.stringify_analyze","title":"<code>stringify_analyze(target, indent=0, label=None)</code>","text":"<p>Stringify node representation of specified target.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>CallableFunction</code> <p>async function to analyze.</p> required <code>indent</code> <code>int</code> <p>level identation (default to zero).</p> <code>0</code> <code>label</code> <code>Optional[str]</code> <p>label of current node (default None).</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>a string node representation.</p> Source code in <code>async_btree/analyze.py</code> <pre><code>def stringify_analyze(target: Node, indent: int = 0, label: Optional[str] = None) -&gt; str:\n    \"\"\"Stringify node representation of specified target.\n\n    Args:\n        target (CallableFunction): async function to analyze.\n        indent (int): level identation (default to zero).\n        label (Optional[str]): label of current node (default None).\n\n    Returns:\n        (str): a string node representation.\n    \"\"\"\n    _ident = \"    \"\n    _space = f\"{_ident * indent} \"\n    result: str = \"\"\n    if label:\n        result += f\"{_space}--({label})--&gt; {target.name}:\\n\"\n        _space += f\"{_ident}{' ' * len(label)}\"\n    else:\n        result += f\"{_space}--&gt; {target.name}:\\n\"\n\n    for k, v in target.properties:\n        result += f\"{_space}    {k}: {v}\\n\"\n\n    for _label, children in target.edges:\n        if children:\n            for child in children:\n                result += stringify_analyze(target=child, indent=indent + 1, label=_label)\n    return result\n</code></pre>"},{"location":"tutorial/","title":"How to create a BehaviorTree","text":"<p>In this tutorial series, most of the time Actions will just print some information on console, but keep in mind that real \"production\" code would probably do something more complicated.</p> <p>The source code of this tutorial is example/tutorial_1.py.</p>"},{"location":"tutorial/#how-to-create-your-own-action","title":"How to create your own Action","text":"<p>Firt, you have to wrote your function (async or sync) as normal, like this:</p> <pre><code>def approach_object(name: str):\n    print(f\"approach_object: {name}\")\n\ndef check_battery():\n    print(\"battery ok\")\n\nasync def say_hello(name: str):\n    print(f\"Hello: {name}\")\n\n</code></pre> <p>At this point, this is not (yet) a behavior action. To define an action, you have to use <code>action</code> function:</p> <pre><code>import async_btree as bt\n\napproach_house_object_action = bt.action(target=approach_object, name=\"house\")\n\ncheck_battery_action = bt.action(target=check_battery)\n\nsay_hello_john = bt.action(target=say_hello, name=\"John\")\n\n</code></pre> <p>With a class like this one:</p> <pre><code>class GripperInterface:\n\n    def __init__():\n        self._open = False\n\n\n    def open(self):\n        print(\"GripperInterface Open\")\n        self._open = True\n\n    def close(self):\n        print(\"GripperInterface Close\")\n        self._open = False\n\n</code></pre> <p>We can define action for these functions:     - GripperInterface.open     - GripperInterface.close</p>"},{"location":"tutorial/#create-a-tree-dynamically","title":"Create a tree dynamically","text":"<p>We will build a sequence of actions like this one:  - say hello  - check battery  - open gripper  - approach object  - close gripper</p> <p>To do that, we need to use <code>sequence</code> methods.</p> <pre><code>\ngripper = GripperInterface()\n\nb_tree = bt.sequence(children= [\n    bt.action(target=say_hello, name=\"John\"),\n    bt.action(target=check_battery),\n    bt.action(target=gripper.open),\n    bt.action(target=approach_object, name=\"house\"),\n    bt.action(target=gripper.close)\n])\n\n</code></pre> <p>Run it:</p> <pre><code>with bt.BTreeRunner() as runner:\n    runner.run(b_tree)\n</code></pre> <p>And you should see:</p> <pre><code>Hello: John\n</code></pre> <p>Why we did not see other action ? It's because our first action did not return a success (something truthy). So we could add a <code>return True</code>, on each our function, like this:</p> <pre><code>def approach_object(name: str):\n    print(f\"approach_object: {name}\")\n    return True\n</code></pre> <p>Or we could rewrote our behavior tree with specific status:</p> <pre><code>b_tree = bt.sequence(children= [\n    bt.always_success(child=bt.action(target=say_hello, name=\"John\")),\n    bt.always_success(child=bt.action(target=check_battery)),\n    bt.always_success(child=bt.action(target=gripper.open)),\n    bt.always_success(child=bt.action(target=approach_object, name=\"house\")),\n    bt.always_success(child=bt.action(target=gripper.close))\n])\n</code></pre> <p>If we running it again:</p> <pre><code>Hello: John\nbattery ok\nGripperInterface Open\napproach_object: house\nGripperInterface Close\n</code></pre> <p>As you could see: - we use a single instance of GripperInterface - we have hard coded name on our action function</p> <p>We can also define a function like this:</p> <pre><code>def check_again_battery():\n    print(\"battery dbl check\")\n    # you should return a success\n    return bt.SUCCESS\n</code></pre> <p>and wrote our behavior tree :</p> <pre><code>b_tree = bt.sequence(\n    children=[\n        bt.always_success(child=bt.action(target=say_hello, name=\"John\")),\n        bt.action(target=check_battery),\n        check_again_battery,  # this will be encapsulated at runtime\n        bt.always_success(child=bt.action(target=gripper.open)),\n        bt.always_success(child=bt.action(target=approach_object, name=\"house\")),\n        bt.always_success(child=bt.action(target=gripper.close)),\n    ]\n)\n</code></pre> <p><code>check_again_battery</code> will be encapsulated at runtime.</p> <p>If we running it again:</p> <pre><code>Hello: John\nbattery ok\nbattery dbl check\nGripperInterface Open\napproach_object: house\nGripperInterface Close\n</code></pre> <p>In a real use case, we should find a way to avoid this: - wrote a factory function for a specific case - either by using ContextVar (<code>from contextvars import ContextVar</code>)</p> <p>You could see a sample in this source is example/tutorial_2_decisions.py.</p>"}]}